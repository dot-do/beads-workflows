/**
 * Workflow initialization
 * Generates global.d.ts and example handlers
 */

import { writeFile, access, mkdir } from 'fs/promises'
import { join } from 'path'

/**
 * Init options
 */
export interface InitOptions {
  createExample?: boolean
}

/**
 * Init result
 */
export interface InitResult {
  success: boolean
  files: string[]
  error?: string
}

/**
 * Generate global.d.ts content
 */
function generateGlobalDts(): string {
  return `/**
 * Global types for beads workflow handlers
 * Auto-generated by beads-workflows
 */

interface Issue {
  id: string
  title: string
  description?: string
  status: 'open' | 'in_progress' | 'closed'
  type: 'task' | 'bug' | 'feature' | 'epic'
  priority: 0 | 1 | 2 | 3 | 4
  assignee?: string
  labels?: string[]
  created: Date
  updated: Date
  closed?: Date
  dependsOn: string[]
  blocks: string[]
  parent?: string
  children?: string[]
}

interface Epic extends Issue {
  type: 'epic'
  children: string[]
}

interface IssuesApi {
  get(id: string): Promise<Issue | null>
  list(filter?: { status?: string; type?: string; assignee?: string }): Promise<Issue[]>
  ready(): Promise<Issue[]>
  blocked(): Promise<Issue[]>
  count(filter?: { status?: string; type?: string }): Promise<number>
  create(options: { title: string; type?: string; priority?: number; description?: string }): Promise<Issue | null>
  update(id: string, options: { status?: string; priority?: number; assignee?: string }): Promise<Issue | null>
  close(id: string, reason?: string): Promise<boolean>
}

interface EpicsApi {
  get(id: string): Promise<Epic | null>
  list(filter?: { status?: string }): Promise<Epic[]>
  children(epicId: string): Promise<Issue[]>
  progress(epicId: string): Promise<{ total: number; closed: number; percentage: number }>
}

declare global {
  /** The current issue being processed (for issue.* events) */
  const issue: Issue

  /** The previous state of the issue (for issue.updated, issue.closed events) */
  const previousIssue: Issue | undefined

  /** The current epic being processed (for epic.* events) */
  const epic: Epic

  /** Issues API for reading and writing issues */
  const issues: IssuesApi

  /** Epics API for reading epics */
  const epics: EpicsApi
}

export {}
`
}

/**
 * Generate tsconfig.json content
 */
function generateTsConfig(): string {
  return JSON.stringify(
    {
      compilerOptions: {
        target: 'ESNext',
        module: 'ESNext',
        moduleResolution: 'bundler',
        strict: true,
        skipLibCheck: true,
        types: ['bun-types'],
        lib: ['ESNext'],
      },
      include: ['*.ts', 'global.d.ts'],
    },
    null,
    2
  )
}

/**
 * Generate example handler content
 */
function generateExampleHandler(): string {
  return `/**
 * Handler for issue.ready event
 * Called when an issue has no blockers and is ready to work on
 */

// The 'issue' global is automatically available
console.log(\`Issue ready: \${issue.id} - \${issue.title}\`)

// You can also use the issues and epics APIs
const allReady = await issues.ready()
console.log(\`Total ready issues: \${allReady.length}\`)
`
}

/**
 * Initialize workflows in a beads directory
 */
export async function initWorkflows(
  beadsDir: string,
  options: InitOptions = {}
): Promise<InitResult> {
  const files: string[] = []

  try {
    // Check directory exists
    await access(beadsDir)
  } catch {
    return {
      success: false,
      files: [],
      error: `Directory does not exist: ${beadsDir}`,
    }
  }

  try {
    // Write global.d.ts
    await writeFile(join(beadsDir, 'global.d.ts'), generateGlobalDts())
    files.push('global.d.ts')

    // Write tsconfig.json
    await writeFile(join(beadsDir, 'tsconfig.json'), generateTsConfig())
    files.push('tsconfig.json')

    // Write example handler if requested
    if (options.createExample) {
      const examplePath = join(beadsDir, 'on.issue.ready.ts')
      try {
        // Check if file already exists
        await access(examplePath)
        // File exists, don't overwrite
      } catch {
        // File doesn't exist, create it
        await writeFile(examplePath, generateExampleHandler())
        files.push('on.issue.ready.ts')
      }
    }

    return { success: true, files }
  } catch (error) {
    return {
      success: false,
      files,
      error: error instanceof Error ? error.message : String(error),
    }
  }
}
